// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     COST_FUNCTION.cpp.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#include "spline3_pose3_camera_linear_bearing_cost_function.hpp"

#include <span>

#include <glog/logging.h>

#include <sym/ops/storage_ops.h>
#include <sym/util/epsilon.h>

#include "sym/spline3_pose3_camera_linear_bearing_factor.hpp"
#include "sym/spline3_pose3_camera_linear_bearing_factor_with_jacobians1234567.hpp"
#include "sym/spline3_pose3_camera_linear_bearing_factor_with_jacobians123457.hpp"
#include "sym/spline3_pose3_camera_linear_bearing_factor_with_jacobians123467.hpp"
#include "sym/spline3_pose3_camera_linear_bearing_factor_with_jacobians12347.hpp"

namespace hyperion {

using namespace sym_hyperion;

auto Spline3Pose3CameraLinearBearingCostFunction::evaluate(Scalar const* const* parameters,
                                                           Scalar* residuals,
                                                           Scalar** jacobians) const -> bool {
  // Create aliases.
  const auto _x0 = sym::StorageOps<sym::Pose3<Scalar>>::FromStorage(parameters[0]);
  const auto _x1 = sym::StorageOps<sym::Pose3<Scalar>>::FromStorage(parameters[1]);
  const auto _x2 = sym::StorageOps<sym::Pose3<Scalar>>::FromStorage(parameters[2]);
  const auto _x3 = sym::StorageOps<sym::Pose3<Scalar>>::FromStorage(parameters[3]);
  const auto _b_T_c = sym::StorageOps<sym::Pose3<Scalar>>::FromStorage(parameters[4]);
  const auto _calibration =
      sym::StorageOps<sym::LinearCameraCal<Scalar>>::FromStorage(parameters[5]);
  const auto _l_w = sym::StorageOps<Eigen::Matrix<Scalar, 3, 1>>::FromStorage(parameters[6]);

  // Evaluation without Jacobians.
  if (!jacobians) {
    Eigen::Map<Eigen::Matrix<Scalar, 1, 1>>{residuals} =
        Spline3Pose3CameraLinearBearingFactor<Scalar>(lambdas_, _x0, _x1, _x2, _x3, _b_T_c,
                                                      _calibration, _l_w, pixel_, sqrt_info_,
                                                      sym::kDefaultEpsilon<Scalar>);
    return true;
  }

  // Evaluation with Jacobians.

  std::span<Scalar*, 7> span{jacobians, 7};
  const auto bits = std::accumulate(
      span.begin(), span.end(), std::uint8_t{0},
      [](const auto x, const auto ptr) { return (x << 1) | std::uint8_t{ptr != nullptr}; });

  switch (bits | std::uint8_t{0b1111001}) {
    case std::uint8_t{0b1111111}: {
      Eigen::Map<Eigen::Matrix<Scalar, 1, 1>>{residuals} =
          Spline3Pose3CameraLinearBearingFactorWithJacobians1234567<Scalar>(
              lambdas_, _x0, _x1, _x2, _x3, _b_T_c, _calibration, _l_w, pixel_, sqrt_info_,
              sym::kDefaultEpsilon<Scalar>, jacobians[0], jacobians[1], jacobians[2], jacobians[3],
              jacobians[4], jacobians[5], jacobians[6]);
      return true;
    }
    case std::uint8_t{0b1111101}: {
      Eigen::Map<Eigen::Matrix<Scalar, 1, 1>>{residuals} =
          Spline3Pose3CameraLinearBearingFactorWithJacobians123457<Scalar>(
              lambdas_, _x0, _x1, _x2, _x3, _b_T_c, _calibration, _l_w, pixel_, sqrt_info_,
              sym::kDefaultEpsilon<Scalar>, jacobians[0], jacobians[1], jacobians[2], jacobians[3],
              jacobians[4], jacobians[6]);
      return true;
    }
    case std::uint8_t{0b1111011}: {
      Eigen::Map<Eigen::Matrix<Scalar, 1, 1>>{residuals} =
          Spline3Pose3CameraLinearBearingFactorWithJacobians123467<Scalar>(
              lambdas_, _x0, _x1, _x2, _x3, _b_T_c, _calibration, _l_w, pixel_, sqrt_info_,
              sym::kDefaultEpsilon<Scalar>, jacobians[0], jacobians[1], jacobians[2], jacobians[3],
              jacobians[5], jacobians[6]);
      return true;
    }
    case std::uint8_t{0b1111001}: {
      Eigen::Map<Eigen::Matrix<Scalar, 1, 1>>{residuals} =
          Spline3Pose3CameraLinearBearingFactorWithJacobians12347<Scalar>(
              lambdas_, _x0, _x1, _x2, _x3, _b_T_c, _calibration, _l_w, pixel_, sqrt_info_,
              sym::kDefaultEpsilon<Scalar>, jacobians[0], jacobians[1], jacobians[2], jacobians[3],
              jacobians[6]);
      return true;
    }
    default: {
      LOG(FATAL) << "Invalid combination.";
      return false;
    }
  }
}

}  // namespace hyperion
